{
  "name": "小游戏-鼠标躲避",
  "desc": "控制鼠标躲开四面八方过来的物体，避免被撞到",
  "tags": ["html", "game"],
  "config": "{\"text\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\">\\n<head>\\n<meta charset=\\\"UTF-8\\\">\\n<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\n<title>线条躲避小游戏</title>\\n<style>\\n  html, body {\\n    margin: 0;\\n    padding: 0;\\n    overflow: hidden;\\n    background: #000;\\n    height: 100%;\\n  }\\n  canvas {\\n    display: block;\\n    cursor: none;\\n  }\\n  #score {\\n    position: absolute;\\n    top: 10px;\\n    left: 10px;\\n    color: #0f0;\\n    font-family: monospace;\\n    font-size: 20px;\\n  }\\n  #gameOverContainer {\\n    position: absolute;\\n    top: 0; left: 0;\\n    width: 100%;\\n    height: 100%;\\n    display: none; /* 默认隐藏 */\\n    flex-direction: column;\\n    justify-content: center;\\n    align-items: center;\\n    background: rgba(0,0,0,0.7);\\n    z-index: 100;\\n    text-align: center;\\n  }\\n  #gameOverContainer h1 {\\n    color: #0f0;\\n    font-family: monospace;\\n    font-size: 50px;\\n    margin: 0 0 20px 0;\\n  }\\n  #gameOverContainer p {\\n    color: #0f0;\\n    font-family: monospace;\\n    font-size: 30px;\\n    margin: 0 0 30px 0;\\n  }\\n  #restartBtn {\\n    padding: 12px 24px;\\n    font-size: 20px;\\n    background: #0f0;\\n    border: none;\\n    border-radius: 8px;\\n    cursor: pointer;\\n    font-family: monospace;\\n  }\\n  #restartBtn:hover {\\n    background: #0c0;\\n  }\\n</style>\\n</head>\\n<body>\\n<div id=\\\"score\\\">Score: 0</div>\\n<div id=\\\"gameOverContainer\\\">\\n  <h1>游戏结束</h1>\\n  <p id=\\\"finalScore\\\">你的分数: 0</p>\\n  <button id=\\\"restartBtn\\\">重新开始</button>\\n</div>\\n<canvas id=\\\"gameCanvas\\\"></canvas>\\n<script>\\nconst canvas = document.getElementById('gameCanvas');\\nconst ctx = canvas.getContext('2d');\\n\\nlet mouse = { x: window.innerWidth/2, y: window.innerHeight/2 };\\nlet obstacles = [];\\nlet score = 0;\\nlet speedMultiplier = 1;\\nlet gameOver = false;\\nlet playerCollisionSize = 15;\\nlet pulse = 0;\\n\\n// 自适应canvas\\nfunction resizeCanvas() {\\n  canvas.width = window.innerWidth;\\n  canvas.height = window.innerHeight;\\n}\\nresizeCanvas();\\nwindow.addEventListener('resize', resizeCanvas);\\n\\n// 鼠标位置\\nwindow.addEventListener('mousemove', e => {\\n  mouse.x = e.clientX;\\n  mouse.y = e.clientY;\\n});\\n\\n// 随机颜色\\nfunction randomColor() {\\n  const r = Math.floor(Math.random()*200+55);\\n  const g = Math.floor(Math.random()*200+55);\\n  const b = Math.floor(Math.random()*200+55);\\n  return `rgb(${r},${g},${b})`;\\n}\\n\\nconst shapeTypes = ['circle','rect','triangle','diamond','star'];\\n\\n// 随机生成障碍\\nfunction createObstacle() {\\n  const size = Math.random() * 20 + 10;\\n  const shapeType = shapeTypes[Math.floor(Math.random()*shapeTypes.length)];\\n  const color = randomColor();\\n  const special = Math.random() < 0.3;\\n  let x, y, vx, vy, angle = 0, rotationSpeed = 0;\\n\\n  const edge = Math.floor(Math.random()*4);\\n  switch(edge) {\\n    case 0: x = Math.random() * canvas.width; y = -size; vx = (Math.random()-0.5)*2; vy = Math.random()*2 + 1; break;\\n    case 1: x = canvas.width + size; y = Math.random() * canvas.height; vx = -(Math.random()*2 + 1); vy = (Math.random()-0.5)*2; break;\\n    case 2: x = Math.random() * canvas.width; y = canvas.height + size; vx = (Math.random()-0.5)*2; vy = -(Math.random()*2 + 1); break;\\n    case 3: x = -size; y = Math.random() * canvas.height; vx = Math.random()*2 + 1; vy = (Math.random()-0.5)*2; break;\\n  }\\n\\n  if (special) rotationSpeed = (Math.random()-0.5)*0.2;\\n\\n  obstacles.push({x, y, vx, vy, size, shapeType, color, special, angle, rotationSpeed});\\n}\\n\\n// 绘制障碍\\nfunction drawObstacle(obs) {\\n  ctx.strokeStyle = obs.color;\\n  ctx.lineWidth = 2;\\n  ctx.save();\\n  ctx.translate(obs.x, obs.y);\\n  if (obs.special) ctx.rotate(obs.angle);\\n\\n  switch(obs.shapeType) {\\n    case 'circle':\\n      ctx.beginPath();\\n      ctx.arc(0,0,obs.size,0,Math.PI*2);\\n      ctx.stroke();\\n      break;\\n    case 'rect':\\n      ctx.strokeRect(-obs.size/2,-obs.size/2,obs.size,obs.size);\\n      break;\\n    case 'triangle':\\n      ctx.beginPath();\\n      ctx.moveTo(0,-obs.size);\\n      ctx.lineTo(obs.size, obs.size);\\n      ctx.lineTo(-obs.size, obs.size);\\n      ctx.closePath();\\n      ctx.stroke();\\n      break;\\n    case 'diamond':\\n      ctx.beginPath();\\n      ctx.moveTo(0,-obs.size);\\n      ctx.lineTo(obs.size,0);\\n      ctx.lineTo(0,obs.size);\\n      ctx.lineTo(-obs.size,0);\\n      ctx.closePath();\\n      ctx.stroke();\\n      break;\\n    case 'star':\\n      const spikes = 5;\\n      const outer = obs.size;\\n      const inner = obs.size/2;\\n      let rot = Math.PI/2*3;\\n      let x=0,y=0;\\n      let step = Math.PI/spikes;\\n      ctx.beginPath();\\n      ctx.moveTo(0,-outer);\\n      for(let i=0;i<spikes;i++){\\n        x = Math.cos(rot)*outer;\\n        y = Math.sin(rot)*outer;\\n        ctx.lineTo(x,y);\\n        rot += step;\\n        x = Math.cos(rot)*inner;\\n        y = Math.sin(rot)*inner;\\n        ctx.lineTo(x,y);\\n        rot += step;\\n      }\\n      ctx.closePath();\\n      ctx.stroke();\\n      break;\\n  }\\n  ctx.restore();\\n}\\n\\n// 绘制玩家碰撞框\\nfunction drawPlayerCollision() {\\n  pulse += 0.1;\\n  const pulseSize = playerCollisionSize + Math.sin(pulse)*5;\\n  ctx.fillStyle = `rgba(0,255,0,0.3)`;\\n  ctx.beginPath();\\n  ctx.arc(mouse.x, mouse.y, pulseSize,0,Math.PI*2);\\n  ctx.fill();\\n  ctx.fillStyle='#0f0';\\n  ctx.beginPath();\\n  ctx.arc(mouse.x, mouse.y, playerCollisionSize,0,Math.PI*2);\\n  ctx.fill();\\n}\\n\\n// 更新障碍\\nfunction updateObstacles() {\\n  for(let i=obstacles.length-1;i>=0;i--){\\n    let obs = obstacles[i];\\n    obs.x += obs.vx*speedMultiplier;\\n    obs.y += obs.vy*speedMultiplier;\\n    if(obs.special) obs.angle += obs.rotationSpeed;\\n    drawObstacle(obs);\\n\\n    let dx = obs.x - mouse.x;\\n    let dy = obs.y - mouse.y;\\n    let distance = Math.sqrt(dx*dx + dy*dy);\\n    if((obs.shapeType==='circle' && distance<obs.size+playerCollisionSize) || \\n       (['rect','triangle','diamond','star'].includes(obs.shapeType) && Math.abs(dx)<obs.size+playerCollisionSize && Math.abs(dy)<obs.size+playerCollisionSize)){\\n      gameOver=true;\\n      document.getElementById('finalScore').innerText='你的分数: '+score;\\n      document.getElementById('gameOverContainer').style.display='flex';\\n    }\\n\\n    if(obs.x<-50||obs.x>canvas.width+50||obs.y<-50||obs.y>canvas.height+50){\\n      obstacles.splice(i,1);\\n      score++;\\n    }\\n  }\\n}\\n\\n// 游戏循环\\nfunction gameLoop(){\\n  if(!gameOver){\\n    ctx.clearRect(0,0,canvas.width,canvas.height);\\n    if(Math.random()<0.02*speedMultiplier) createObstacle();\\n    speedMultiplier+=0.0001;\\n    updateObstacles();\\n    drawPlayerCollision();\\n    document.getElementById('score').innerText='Score: '+score;\\n    requestAnimationFrame(gameLoop);\\n  }\\n}\\n\\n// 重置游戏\\nfunction resetGame(){\\n  obstacles=[];\\n  score=0;\\n  speedMultiplier=1;\\n  pulse=0;\\n  gameOver=false;\\n  document.getElementById('gameOverContainer').style.display='none';\\n  gameLoop();\\n}\\n\\ndocument.getElementById('restartBtn').addEventListener('click',resetGame);\\n\\ngameLoop();\\n</script>\\n</body>\\n</html>\\n\",\"params\":[]}",
  "style": ".htmlContent {\n  border: double 4px transparent;\n  background-image: linear-gradient(white, white), \n                   linear-gradient(to right, #6366f1, #ec4899);\n  background-origin: border-box;\n  background-clip: padding-box, border-box;\n  height: calc(100% - 4px);\n  width: calc(100% - 4px);\n  border-radius: 8px;\n\n  .result {\n    border-radius: 4px;\n  }\n}",
  "w": 13,
  "h": 16,
  "type": "html"
}